\documentclass[noraggedright]{turabian-researchpaper}

% Turabian Formatting
\usepackage{turabian-formatting}

% Chicago Bibliography Formatting
\usepackage[
  autocite = footnote,
  sorting=ynt,
  annotation]
  {biblatex-chicago}
   
\renewcommand{\bibfont}{\normalsize}
\addbibresource{Bibliography.bib}

% Language and Text Formatting
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{microtype}
\usepackage[greek, english]{babel}
  \babeltags{en = english}
  \babeltags{el = greek}
\usepackage{teubner}

% Packages recommended for Turabian
\usepackage{threeparttable}
\usepackage{ellipsis}
\usepackage{tocloft}
\usepackage{csquotes}

% Title Page
\title{This Great Flood of Words\thanks{Rep. 1: 344 d1}}
\subtitle{A Brief Phasal Analysis of the Dialogue
  between Socrates and Thrasymachus}
\author{Thomas Broadwater}
\course{GREK 8010: Readings and Research in Greek Literature}
\submissioninfo{}
\date{\today}

\begin{document}
\SweaveOpts{concordance=TRUE}

<<Packages, echo = F>>=
library(tidyverse) #Tidy data
library(tidytext) #Text mining (unnest tokens)
library(stringr) #Text manipulation
library(dplyr) #Data manipulation
library(readxl) #Importing .xml's
library(janitor) #Cleaning data frames
library(textdata) #Access the AFINN sentiment dictionary
library(patchwork) #Free faceting of figures
@

<<Importing, echo = F>>=
### IMPORTING DATA -------------------------------------------------------------
# Import the Raw Data Set
nested_dialogue <- read_excel("/Users/thomasbroadwater/Documents/UGA/Classes/Spring22/Plato/PhasalAnalysis/ThrasymachusPhasalAnalysis/SocVsThrasEx.xlsx", sheet = "Typology ") %>%
  as_tibble() %>%
  clean_names()

# Prepare for data analysis: one-token-per-row format
# Include the column "index" for easier re-organization down the line
unnested_dialogue <- nested_dialogue %>%
  unnest_tokens(word, text)
unnested_dialogue <- unnested_dialogue %>%
  add_column(index = c(1:nrow(unnested_dialogue)),
             .before = "start_page")

# Color blind-safe palette to be used later
cbPalette <- c("#999999", "#E69F00", "#F0E442", "#009E73", "#56B4E9", "#0072B2", "#D55E00", "#CC79A7")
@

<<Function Definition, echo = F>>=
### Functions ------------------------------------------------------------------
find_mode <- function(x) {
  u <- unique(x)
  tab <- tabulate(match(x, u))
  
  if (length(u[tab == max(tab)]) > 1) {NA}
  else {u[tab == max(tab)]}
  
}
@


\maketitle

\input{Sections/Methodology.Rnw}
%\input{Sections/Sentences.Rnw}

\section{Sentences per Turn (Turn Density)}

<<Turn Density, echo = F>>=
### CONSECUTIVE SENTENCES ------------------------------------------------------
# Consecutive Sentences by Turn
republic_turn_conseq <- nested_dialogue %>% 
  add_count(turn) %>%
  distinct(speaker, turn, n)

republic_turn_conseq <- republic_turn_conseq %>%
  add_column(index = c(1:nrow(republic_turn_conseq)),
             .before = "speaker")

# Gather turn Data
cleitophon_conseq <- republic_turn_conseq %>%
  filter(str_detect(speaker, "Cleitophon") == T)
glaucon_conseq <- republic_turn_conseq %>%
  filter(str_detect(speaker, "Glaucon") == T)
polemarchus_conseq <- republic_turn_conseq %>%
  filter(str_detect(speaker, "Polemarchus") == T)
socrates_conseq <- republic_turn_conseq %>%
  filter(str_detect(speaker, "Socrates") == T)
thrasymachus_conseq <- republic_turn_conseq %>%
  filter(str_detect(speaker, "Thrasymachus") == T)

# Generate table from data
dot <- tibble(
  speaker = c("global", "cleitophon", "glaucon", "polemarchus", "socrates", "thrasymacus"),
  mean = c(mean(republic_turn_conseq$n),
                mean(cleitophon_conseq$n),
                mean(glaucon_conseq$n),
                mean(polemarchus_conseq$n),
                mean(socrates_conseq$n),
                mean(thrasymachus_conseq$n)),
  median = c(median(republic_turn_conseq$n),
             median(cleitophon_conseq$n),
             median(glaucon_conseq$n),
             median(polemarchus_conseq$n),
             median(socrates_conseq$n),
             median(thrasymachus_conseq$n)),
  mode = c(find_mode(republic_turn_conseq$n),
           find_mode(cleitophon_conseq$n),
           find_mode(glaucon_conseq$n),
           find_mode(polemarchus_conseq$n),
           find_mode(socrates_conseq$n),
           find_mode(thrasymachus_conseq$n)),
  sd = c(sd(republic_turn_conseq$n),
         sd(cleitophon_conseq$n),
         sd(glaucon_conseq$n),
         sd(polemarchus_conseq$n),
         sd(socrates_conseq$n),
         sd(thrasymachus_conseq$n))
)

rm(cleitophon_conseq,
   glaucon_conseq,
   polemarchus_conseq,
   socrates_conseq,
   thrasymachus_conseq)

# Graph of Turns
turn_conseq <- republic_turn_conseq %>%
  ggplot() +
  scale_fill_manual(values=cbPalette) +
  geom_bar(mapping = aes(x=index, y=n, fill=speaker), stat = "identity") + # prevents geom_bar() from reorganizing
  geom_smooth(mapping = aes(x=index, y=n), se = F, method = "loess") +
  theme(axis.text.x = element_text(angle = 90)) +
  xlab("Turn (Index)") +
  ylab("Sentences")
@


The first portion of the code tallies the number of sentences per turn, hoping
to identify a correlation between turn ``density'' and the occurrence of phase
transitions. It counts the data in two ways. First, it gathers ``global''
calculations, i.e., the relevant information from the entire dialogue, and
second, it gathers speaker-by-speaker calculations. In order to construct a
high-level view of turn density, the script returns a table of calculations.
The mean represents the average number of sentences per turn, the median
represents the middle value when the data is organized numerically, and the mode
represents the middle value when organized. The standard deviation represents
the overall variation within the data. The table is printed below.

\begin{table}[htbp]
<<dot, echo = F>>=
print(dot)
@
\caption{Turn Density Data}
\label{tab:DensityData}
\end{table}

The table shows notably regular results. Each speaker's average sentence
density is close to the global, $P_{\bar{x}g} = 1.68$. Cleitophon and Socrates
deviate the most, $P_{\bar{x}c} = 1.33$ and $P_{\bar{x}s} = 1.99$, respectively, but
the variations are slight, making it difficult to tell what difference is
significant. The script performs a t-test comparing the global mean to each
speaker's to solve this problem. This test will return a figure called a
p-value for each speaker. For the purposes of this study, if a p-value is less
than 0.05, then the difference between the speaker's mean and the global mean
are significantly different. The results of the test are printed below.

\begin{table}[htbp]
<<T Test (Avg), echo = F>>=
for (i in c(2:6)) {
  val <- t.test(c(dot$mean[1], dot$mean[i]))$p.value
  paste(dot$speaker[i], val, sep = ": ") %>%
    print()
  }
@
\caption{P-Values: Average Turn Density by Speaker}
\label{tab:DensityPval}
\end{table}

Interestingly, only Polemarchus shows a statistically significant deviation from
the global mean. In Polemarchus' case, the small sample size may skew the data.
Polemarchus only has four turns in the entire dialogue. His third turn (P3) is
three sentences long, P2 is two sentences long, and P1 and P4 are both one
sentence long. As such, his result here provides little insight. 

Without any useful p-values to rely on, it becomes helpful to visualize the
data. Below is a histogram representing each turn in the order of occurrence.
The x-axis represents the index — a number identifying each turn in the data
set — and the y-axis represents the number of sentences in each turn. The blue
line represents the global mean density over time.

\begin{figure}[htbp]
<<Turn_Conseq, echo = F, fig = T>>=
print(turn_conseq)
@
\caption{Sentence Density by Speaker}
\label{graph:SentenceDensity}
\end{figure}

As reported by the initial data, the dialogue shows a consistent regularity in
sentence density. However, Socrates and Thrasymachus both show greater variation
than the others, especially in the early half of the text. 
This variation is measured by the standard deviations above. A similar t-test on
them reveals that both have a significantly high range of sentence densities:
$P_{\sigma s} = 0.02$ and $P_{\sigma t} = 0.01$ (both rounded), respectively. These
p-values imply that significantly denser turns than the average should be
considered when defining phases.

\begin{table}
<<T Test (SD), echo = F>>=
# Quick p-values of standard deviations
for (i in c(2:6)) {
  val <- t.test(c(dot$sd[1], dot$sd[i]))$p.value
  paste(dot$speaker[i], val, sep = ": ") %>%
    print()
}
@
\caption{P-Values: Standard Deviation of Turn Density by Speaker}
\label{tab:DSDPval}
\end{table}

\section{Words per Turn (Turn Length)}

<<Turn Length, echo = F>>=
### TURN LENGTHS ---------------------------------------------------------------
# Turn and Sentence Length
# count() is essentially group_by(a, b) %>% summarise(n = n())
# summarise truncates and sorts
# add_count() swaps summarise for mutate, which does neither
# add_count() %>% distinct effectively truncates without resorting
# also adding an index

# Length of Turn by Words
republic_turn_length <- unnested_dialogue %>%
  count(reorder(turn, index), speaker, sort = FALSE)
republic_turn_length <- republic_turn_length  %>%
  add_column(index = c(1:nrow(republic_turn_length)),
             .before = "reorder(turn, index)")

names(republic_turn_length) <- c("index", "turn", "speaker", "length (words)") %>%
  make_clean_names()

republic_turn_length <- republic_turn_length %>% #reorder to match sentence length
  relocate("speaker", .before = "turn")

# Gather turn Data
cleitophon_length <- republic_turn_length %>%
  filter(str_detect(speaker, "Cleitophon") == T)
glaucon_length <- republic_turn_length %>%
  filter(str_detect(speaker, "Glaucon") == T)
polemarchus_length <- republic_turn_length %>%
  filter(str_detect(speaker, "Polemarchus") == T)
socrates_length <- republic_turn_length %>%
  filter(str_detect(speaker, "Socrates") == T)
thrasymachus_length <- republic_turn_length %>%
  filter(str_detect(speaker, "Thrasymachus") == T)

lot <- tibble(
  speaker = c("global", "cleitophon", "glaucon", "polemarchus", "socrates", "thrasymacus"),
  mean = c(mean(republic_turn_length$length_words),
           mean(cleitophon_length$length_words),
           mean(glaucon_length$length_words),
           mean(polemarchus_length$length_words),
           mean(socrates_length$length_words),
           mean(thrasymachus_length$length_words)),
  median = c(median(republic_turn_length$length_words),
             median(cleitophon_length$length_words),
             median(glaucon_length$length_words),
             median(polemarchus_length$length_words),
             median(socrates_length$length_words),
             median(thrasymachus_length$length_words)),
  mode = c(find_mode(republic_turn_length$length_words),
           find_mode(cleitophon_length$length_words),
           find_mode(glaucon_length$length_words),
           find_mode(polemarchus_length$length_words),
           find_mode(socrates_length$length_words),
           find_mode(thrasymachus_length$length_words)),
  sd = c(sd(republic_turn_length$length_words),
         sd(cleitophon_length$length_words),
         sd(glaucon_length$length_words),
         sd(polemarchus_length$length_words),
         sd(socrates_length$length_words),
         sd(thrasymachus_length$length_words))
)

rm(cleitophon_length,
   glaucon_length,
   polemarchus_length,
   socrates_length,
   thrasymachus_length)

# Global Sentence Length Bar Plot - - - - - - - - - - - - - - - - - - - - - - -
# makes a stacked bar plot of turn lengths
# stacks of sentences by length
# Really kills two birds with one stone, but it's a bit informationally dense
# changed republic_sentence_length to " "_turn_" " to clean it up
# changed color and _color_ to fill and _fill_
turn_length <- republic_turn_length %>%
  ggplot() +
  scale_fill_manual(values=cbPalette) +
  geom_bar(mapping = aes(x=index, y=length_words, fill = speaker), stat = "identity") + # prevents geom_bar() from reorganizing
  geom_smooth(mapping = aes(x=index, y=length_words), se = F, method = "loess") +
  theme(axis.text.x = element_text(angle = 90)) +
  xlab("Turn (Index)") +
  ylab("Words")
@

The second part of the script follows the same pattern as the first, but now
tallies the number of words per turn, hoping to establish a correlation between
turn ``length'' and phase transitions.

Once again, the results are relatively consistent. Polemarchus, with his small
sample size, shows a statistically significant increase in words per turn,
giving him a noticeably high average turn length. However, when subject to a
t-test, the other interlocutors show p-values much higher than 0.05, indicating
that their averages are not statistically significant.

\begin{table}[htbp]
<<dot, echo = F>>=
print(lot)
@
\caption{Turn Length Data}
\label{tab:LengthData}
\end{table}

\begin{table}[htbp]
<<Len T Test (Avg), echo = F>>=
# Quick p-values of means
for (i in c(2:6)) {
  val <- t.test(c(lot$mean[1], lot$mean[i]))$p.value
  paste(lot$speaker[i], val, sep = ": ") %>%
    print()
}
@
\caption{P-Values: Average Turn Length by Speaker}
\label{tab:LenPval}
\end{table}

Socrates and Thrasymachus again show significantly higher standard deviations,
owing to a greater variety in turn length. Their p-values are
$P_{\sigma s} = 0.02$ and $P_{\sigma t} = 0.01$ (both rounded), respectively. 

\begin{table}[htbp]
<<Len T Test (SD), echo = F>>=
for (i in c(2:6)) {
  val <- t.test(c(dot$sd[1], dot$sd[i]))$p.value
  paste(dot$speaker[i], val, sep = ": ") %>%
    print()
}
@
\caption{P-Values: Standard Deviation of Turn Length by Speaker}
\label{tab:LSDPval}
\end{table}

The script once generates a histogram with a moving average, but now a
resemblance to the turn density chart becomes apparent. For comparison, both
figure \ref{graph:SentenceDensity} and the new figure \ref{graph:SentenceLength}
are reprinted below.

\begin{figure}[htbp]
<<Turn_Length, echo = F, fig = T>>=
print(turn_length / turn_conseq)
@
\caption{Sentence Length by Speaker (Above) and Figure \ref{graph:SentenceDensity}. (Below)}
\label{graph:SentenceLength}
\end{figure}

\end{document}
